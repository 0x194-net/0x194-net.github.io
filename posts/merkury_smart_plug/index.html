<!doctype html><html lang=en><head><title>Voiding the Warranty - Merkury Smart Plug ::
0x194</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The Cause - Why do this? # Studying infosec and IoT device security has given me a desire to create my own gadgets and practice some of what I&amp;rsquo;ve learned. What better way than destroying some cheap off-the-shelf devices found at a local store and share my process with others?
Some may ask, &amp;ldquo;why would I do that when there are options such as Arduino, ESP32, and ESP8266 that are available?"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://0x194.net/posts/merkury_smart_plug/><link rel=stylesheet href=https://0x194.net/assets/style.css><link rel=stylesheet href=https://0x194.net/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://0x194.net/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://0x194.net/img/favicon.png><link href=https://0x194.net/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://0x194.net/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://0x194.net/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://0x194.net/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://0x194.net/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://0x194.net/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="Voiding the Warranty - Merkury Smart Plug"><meta name=twitter:description content="The Cause - Why do this? # Studying infosec and IoT device security has given me a desire to create my own gadgets and practice some of what I&rsquo;ve learned. What better way than destroying some cheap off-the-shelf devices found at a local store and share my process with others?
Some may ask, &ldquo;why would I do that when there are options such as Arduino, ESP32, and ESP8266 that are available?"><meta property="og:title" content="Voiding the Warranty - Merkury Smart Plug"><meta property="og:description" content="The Cause - Why do this? # Studying infosec and IoT device security has given me a desire to create my own gadgets and practice some of what I&rsquo;ve learned. What better way than destroying some cheap off-the-shelf devices found at a local store and share my process with others?
Some may ask, &ldquo;why would I do that when there are options such as Arduino, ESP32, and ESP8266 that are available?"><meta property="og:type" content="article"><meta property="og:url" content="https://0x194.net/posts/merkury_smart_plug/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-21T12:30:03-05:00"><meta property="article:modified_time" content="2022-10-21T12:30:03-05:00"><meta property="og:site_name" content="0x194"></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>mascencerro@0x194:~ $</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/contact>Contact</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/contact>Contact</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>Voiding the Warranty - Merkury Smart Plug</h1><div class=post-meta><span class=post-date>2022-10-21</span>
<span class=post-read-time>— 13 min read</span></div><span class=post-tags><a href=https://0x194.net/tags/tryharder/>[tryharder]</a>&nbsp;
<a href=https://0x194.net/tags/iot/>[iot]</a>&nbsp;
<a href=https://0x194.net/tags/firmware/>[firmware]</a>&nbsp;
<a href=https://0x194.net/tags/devices/>[devices]</a>&nbsp;</span><div class=post-content><h2>Table of Contents</h2><aside class=table-of-contents><nav id=TableOfContents><ul><li><a href=#the-cause---why-do-this>The Cause - Why do this?</a></li><li><a href=#the-victim---choosing-the-device>The Victim - Choosing the device</a></li><li><a href=#making-connections---lets-get-physical>Making Connections - Lets get physical</a></li><li><a href=#device-log-setup---listening-in>Device Log Setup - Listening in</a></li><li><a href=#firmware-dump-setup---a-look-inside>Firmware Dump Setup - A look inside</a></li><li><a href=#preparing-a-development-environment>Preparing a Development Environment</a></li><li><a href=#the-final-boss---flashing>The Final Boss - Flashing</a></li></ul></nav></aside><h2 id=the-cause---why-do-this>The Cause - Why do this?
<a href=#the-cause---why-do-this class=h-anchor aria-hidden=true>#</a></h2><p>Studying infosec and IoT device security has given me a desire to create my own gadgets and practice some of what I&rsquo;ve learned. What better way than destroying
some cheap off-the-shelf devices found at a local store and share my process with others?</p><p>Some may ask, &ldquo;why would I do that when there are options such as Arduino, ESP32, and ESP8266 that are available?&rdquo;</p><ul><li><p><strong>Availability</strong><br>Since I am located out in a rather rural area, if I want an Arduino board or similar, I have to order it online. After I pay
for the device and additional shipping, I patiently wait for my device to arrive in the hopes that the order is correct, and the device is functional.
By sourcing inexpensive devices locally, I can cut cost, avoid shipping, and skip waiting and crossing my fingers. Also, these devices are usually sold
in packs of 2-4 at a cost comparable or cheaper than the cost of a single Arduino without shipping added.</p></li><li><p><strong>Peripherals</strong><br>Although these devices usually function as simple hardware such as a light bulb or power plug, there is much more to them. Smart devices contain a processor
as well as WiFi and Bluetooth chipsets to provide internet connectivity to enable remote control and timer programming capability.
Included in the device I will be modifying is a WiFi adapter (capable of acting as access point <em>and</em> station simultaneously), Bluetooth capability, GPIO, and I2C!<br>To add such functionality to some Arduino, ESP32, or ESP8266 would require additional parts, which would in turn incur additional cost per project.</p></li><li><p><strong>Versatility</strong><br>Smart devices have an operating system of some form such as Linux or an RTOS. This means they have a program that instructs the device what to do,
and that program is usually modifiable if it can be accessed and written to. If I can figure out how to flash my own firmware to these devices,
I can write my own code, utilize additional libraries, and perform functions with the device not intended by the manufacturer.</p></li></ul><p>I don&rsquo;t see a reason <em>not</em> to at least give it a try.</p><p>So, without further ado, let&rsquo;s break something.</p><hr><p> </p><h2 id=the-victim---choosing-the-device>The Victim - Choosing the device
<a href=#the-victim---choosing-the-device class=h-anchor aria-hidden=true>#</a></h2><p>The first device I chose to violate is a Merkury Smart Plug. These are currently sold near me for around $13 a pair (yay for spare).<br><figure class=center><a href=/img/merkury_smart_plug/box.jpg><img src=/img/merkury_smart_plug/box.jpg></a><figcaption class=center><a href=https://mygeeni.com/products/merkury-innovations-smart-plug-requires-2-4ghz-wifi>https://mygeeni.com/products/merkury-innovations-smart-plug-requires-2-4ghz-wifi</a></figcaption></figure></p><table><thead><tr><th style=text-align:center>Plug Front</th><th style=text-align:center>Plug Back</th></tr></thead><tbody><tr><td style=text-align:center><figure class=left><a href=/img/merkury_smart_plug/plug1.jpg><img src=/img/merkury_smart_plug/plug1.jpg></a><figcaption class=center>Simple front with LED</figcaption></figure></td><td style=text-align:center><figure class=left><a href=/img/merkury_smart_plug/plug2.jpg><img src=/img/merkury_smart_plug/plug2.jpg></a><figcaption class=center>Model:MI-WW218-199WW FCCID: 2AJ3WEBECZW03</figcaption></figure></td></tr></tbody></table><p>If we search for the FCCID 2AJ3WEBECZW03 from the back of the device at
<a href="https://apps.fcc.gov/oetcf/eas/reports/ViewExhibitReport.cfm?mode=Exhibits&RequestTimeout=500&calledFromFrame=N&application_id=yl2hr7pvnYtSU5TBbzIdXQ%3D%3D&fcc_id=2AJ3WEBECZW03">fcc.gov</a>
we will find disassembled photos showing that the cover is held on by glue around the edge. We can also see the part number for the chipset, but it is hard to make out for certain.</p><p>Using two small screwdrivers I was able to pry around the edge until the cover finally popped off. It doesn&rsquo;t look pretty and new, but function is more important than form here.</p><table><thead><tr><th style=text-align:center>Under The Hood</th></tr></thead><tbody><tr><td style=text-align:center><figure class=left><a href=/img/merkury_smart_plug/plug_cut1.jpg><img src=/img/merkury_smart_plug/plug_cut1.jpg></a></figure></td></tr></tbody></table><p>We can see on the back of this chipset a few interesting, labeled contacts such as two pair of <code>RX/TX</code>, a <code>VBAT</code>, as well as <code>GND</code>. These are what we
will be utilizing for communication and flashing of the controller.</p><p>On the front of the chipset we see it is labeled as <code>Model: WB2S</code>. A quick Google search will lead us to <a href="https://developer.tuya.com/en/docs/iot/wb2s-module-datasheet?id=K9ghecl7kc479">the WB2S datasheet provided by Tuya</a>.</p><figure class=center><a href=/img/merkury_smart_plug/chipset_front.jpg><img src=/img/merkury_smart_plug/chipset_front.jpg></a><figcaption class=center>Front of controller with Model: W2BS</figcaption></figure><p>A basic rundown of what we have from the datasheet:</p><blockquote><p>Overview<br>WB2S contains a low-power Arm Cortex-M4 microcontroller unit (MCU), 1T1R WLAN module, 256 KB static random-access memory (SRAM), 2 MB flash memory, and extensive peripherals.<br>WB2S is an RTOS platform that integrates all function libraries of the Wi-Fi MAC and TCP/IP protocols. You can develop embedded Wi-Fi products as required.</p></blockquote><p>The specific features of the device:</p><blockquote><p>Features<br>Embedded low-power 32-bit CPU, which can also function as an application processor<br>Clock rate: 120 MHz<br>Working voltage: 3.0 V to 3.6 V<br>Peripherals: nine GPIOs, one universal asynchronous receiver/transmitter (UART), and one analog-to-digital converter (ADC)<br>Wi-Fi connectivity<br>802.11b/g/n<br>Channels 1 to 14 at 2.4 GHz<br>Support WEP, WPA/WPA2, WPA/WPA2 PSK (AES) ,WPA3 security modes<br>Up to +16 dBm output power in 802.11b mode<br>EZ net pairing mode for Android and iOS devices<br>On-board PCB antenna with a gain of -1.0dBi<br>Working temperature: -40°C to +85°C<br>Bluetooth LE<br>Support Bluetooth (V4.2)<br>Maximum output power + 6dBm<br>Onboard PCB antenna</p></blockquote><p>So, it says we have a 120 MHz ARM Cortex-M4 mpu, 256KB RAM, 2MB flash, 2.4Ghz Beken BK7231T wireless chipset, Bluetooth LE, GPIO, UART, and ADC.
The WB2S chipset also happens to run the open source Real-Time Operating System <a href=https://www.freertos.org/>FreeRTOS</a>.<br>Not a bad deal for about $6.50 total.</p><p>Even though the connections are thankfully labeled on the chip, the datasheet also includes a diagram as well. Thanks Tuya!</p><table><thead><tr><th style=text-align:center>WB2S Diagram</th></tr></thead><tbody><tr><td style=text-align:center><figure class=center><a href=/img/merkury_smart_plug/contact_diagram.png><img src=/img/merkury_smart_plug/contact_diagram.png></a><figcaption class=center>Source: <a href="https://developer.tuya.com/en/docs/iot/wb2s-module-datasheet?id=K9ghecl7kc479">https://developer.tuya.com/en/docs/iot/wb2s-module-datasheet?id=K9ghecl7kc479</a></figcaption></figure></td></tr></tbody></table><hr><p> </p><h2 id=making-connections---lets-get-physical>Making Connections - Lets get physical
<a href=#making-connections---lets-get-physical class=h-anchor aria-hidden=true>#</a></h2><p>Since this is my first time working with the actual firmware of a device, I took to Google again. Surely someone else
has tried to work with these devices, right? After reading through a handful reddit and forum posts asking about the Tuya WB2S, I stumbled onto
a forum post at <a href=https://www.elektroda.com>Elektroda</a>:</p><ul><li><a href=https://www.elektroda.com/rtvforum/topic3850712.html>WB2S/BK7231 Tutorial - writing custom firmware - UDP/TCP/HTTP/MQTT @ elektroda</a></li></ul><p>In the discussion the author describes exactly how he was able to connect the device, read the log output, and flash the device with custom firmware.
This sounds to me to be pretty spot-on for what we&rsquo;re needing.</p><p>Tuya has also made the SDK for the chipset open source available <a href=https://github.com/tuya/tuya-iotos-embeded-sdk-wifi-ble-bk7231t>here</a>.</p><p>While searching for more information on the SDK and BK7231T chipset, I found:</p><ul><li><a href=https://rb9.nl/posts/2022-03-29-light-jailbreaking-exploiting-tuya-iot-devices/>Light jailbreaking: exploiting Tuya IoT devices for fun and profit</a></li></ul><p>In the write-up, the researchers describe how they went about finding a vulnerability with the Tuya SDK allowing them to jailbreak the device and install
custom firmware with OTA update. I was later able to find <a href=https://youtu.be/uZXSMUp2bgU>the video</a> from their presentation at <a href=https://mch2022.org/>MCH2022</a>
regarding the vulnerability and after their disclosure to Tuya which I think is worth the watch.</p><p>This thing is going to be fun!</p><p>Now, getting back to business, I needed to be able to handle the plug without risk of being shocked by the AC portion of the device while also having access for wiring,
so I removed a section of the case for a window. After modifying the case to accommodate wiring, I attached leads to the following connections on the chip:</p><ul><li>VBAT 3.3v power</li><li>GND ground</li><li>RX1/TX1 uart programming</li><li>RX2/TX2 uart logging</li><li>CEN reset</li></ul><p>The contact pads are very delicate, so it is recommended to make sure the wiring is extra stable. In the case that one of those pads is pulled even slightly it can
separate from the PCB and it may take a bit of finesse to make a new lead on the board. I experienced that with another chipset from a bulb, so I decided to reinforce
the connection with hot glue for a little extra insurance.</p><table><thead><tr><th style=text-align:center>Modified Case Installed</th><th style=text-align:center>Ugly But Works</th></tr></thead><tbody><tr><td style=text-align:center><figure class=left><a href=/img/merkury_smart_plug/plug_cut2.jpg><img src=/img/merkury_smart_plug/plug_cut2.jpg></a></figure></td><td style=text-align:center><figure class=left><a href=/img/merkury_smart_plug/ugly_but_works.jpg><img src=/img/merkury_smart_plug/ugly_but_works.jpg></a></figure></td></tr></tbody></table><p>I needed a way to connect this device to my computer. What I settled on using were 2x<a href=http://www.hiletgo.com/ProductDetail/2152064.html>FT232RL FTDI Usb to TTL Serial Adapter</a>
that I ordered from Amazon for around $6/each.</p><p>Since I only the VCC/GND and RX/TX were needed from each, I was able to use the pins without doing any more soldering. I needed one FTDI adapter
for the logging console, and the other to do the programming. The CEN lead will be left open for now as it touched to GND to reset the chip.</p><table><thead><tr><th style=text-align:center>FT232RL Front</th><th style=text-align:center>FT232RL Back</th></tr></thead><tbody><tr><td style=text-align:center><figure class=left><a href=/img/merkury_smart_plug/ft232rl_front.jpg><img src=/img/merkury_smart_plug/ft232rl_front.jpg></a></figure></td><td style=text-align:center><figure class=left><a href=/img/merkury_smart_plug/ft232rl_back.jpg><img src=/img/merkury_smart_plug/ft232rl_back.jpg></a></figure></td></tr></tbody></table><table><thead><tr><th style=text-align:center>Device to Logging Serial Adapter</th><th style=text-align:center>Device to Programming Serial Adapter</th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>VBAT -> VCC</td></tr><tr><td style=text-align:center></td><td style=text-align:center>GND -> GND</td></tr><tr><td style=text-align:center>2RX -> TX</td><td style=text-align:center>1RX -> TX</td></tr><tr><td style=text-align:center>2TX -> RX</td><td style=text-align:center>1TX -> RX</td></tr></tbody></table><p>I scavenged a reset switch from an old Dell desktop case to make life easier with resets, but it is not required.</p><table><thead><tr><th style=text-align:center>Wired Up</th><th style=text-align:center>Reset Switch</th></tr></thead><tbody><tr><td style=text-align:center><figure class=left><a href=/img/merkury_smart_plug/connect1.jpg><img src=/img/merkury_smart_plug/connect1.jpg></a><figcaption class=center>After connecting the logging serial adapter.</figcaption></figure></td><td style=text-align:center><figure class=left><a href=/img/merkury_smart_plug/connect2.jpg><img src=/img/merkury_smart_plug/connect2.jpg></a><figcaption class=center>My Final setup including a reset switch scavanged from an older Dell desktop case.</figcaption></figure></td></tr></tbody></table><hr><p> </p><h2 id=device-log-setup---listening-in>Device Log Setup - Listening in
<a href=#device-log-setup---listening-in class=h-anchor aria-hidden=true>#</a></h2><p>Time to test the connections. First, I connected the FTDI that is connected to 2RX/2TX to the computer. For each of the serial adapters, a USB cable was used to connect
instead of plugging directly into the USB port so everything wasn&rsquo;t crammed into one place. Once connected, I checked to see what serial port it had been assigned.</p><table><thead><tr><th style=text-align:center>For Windows10 open Device Manager with either right-click on the <code>Start</code> button or press the Windows key and <code>x</code>, then select <code>Device Manager</code> from the menu</th><th style=text-align:center>Find the <em>Ports (COM & LPT)</em> section</th></tr></thead><tbody><tr><td style=text-align:center><figure class=center><img src=/img/merkury_smart_plug/windows_device_manager.png></figure></td><td style=text-align:center><figure class=center><img src=/img/merkury_smart_plug/windows_log_com.png><figcaption class=center>Windows10 COM port</figcaption></figure></td></tr></tbody></table><p>For Linux the command <code>ls /dev/ttyUSB*</code> from a terminal prompt will list the USB serial tty devices</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>user@host:~ $ ls /dev/ttyUSB*
</span></span><span style=display:flex><span>/dev/ttyUSB0
</span></span></code></pre></div><p> <br>To capture logging output I needed a terminal application to read the information being sent from the device. <a href=https://www.putty.org/>PuTTY</a> works really well for this job with Windows.
A good terminal application for Linux would be the tried and true <a href=https://en.wikipedia.org/wiki/Minicom>minicom</a>.</p><p>Using PuTTY, I set the connection up as follows using COM3 from our device listing with a speed of 115200 baud and opened the connection.<figure class=center><a href=/img/merkury_smart_plug/putty_config.png><img src=/img/merkury_smart_plug/putty_config.png></a><figcaption class=center>COM3 to FTDI connected to UART1</figcaption></figure> <br>Because the plug will be powered from the FTDI device connected to the programming uart (1RX/1TX), I then connected the second adapter to the computer and was immediately greeted
with successful results. The log starts with the chip initializing and then goes through the bootloader and finally the application loads and searching for connection.<figure class=center><a href=/img/merkury_smart_plug/putty_boot.png><img src=/img/merkury_smart_plug/putty_boot.png></a><figcaption class=center>Merkury smart plug boot log</figcaption></figure></p><hr><p> </p><h2 id=firmware-dump-setup---a-look-inside>Firmware Dump Setup - A look inside
<a href=#firmware-dump-setup---a-look-inside class=h-anchor aria-hidden=true>#</a></h2><pre><code>Prerequisites:
- Git Bash (actually optional, but what I used for my terminal)
- Python 3
</code></pre><p>This is the part where it really starts to get interesting. Once logging was established, it was time to take the programming uart (1RX/1TX) adapter for a spin.</p><p>While it is probably possible to do this section with Powershell, I have <a href=https://git-scm.com/>Git Bash</a> which makes using a text console from Windows much more pleasant.</p><p>There is a Beken &lsquo;official&rsquo; flashing application that was located for doing this part, but I found it to be completely useless because all it did was fail to connect. Instead I chose to use
<a href=https://github.com/OpenBekenIOT/hid_download_py>this fork of hid_download_py</a> for the flash reading/writing. This will require an installation of <a href=https://www.python.org/>Python 3</a> to run.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>git clone https://github.com/OpenBekenIOT/hid_download_py.git
</span></span></code></pre></div><p><figure class=center><a href=/img/merkury_smart_plug/hid_download_py.png><img src=/img/merkury_smart_plug/hid_download_py.png></a><figcaption class=center>Clone <a href=https://github.com/OpenBekenIOT/hid_download_py.git>https://github.com/OpenBekenIOT/hid_download_py.git</a> repository</figcaption></figure>I now had a clone of the repository in the current directory, but it may need a few extra Python modules for the scripts to run.
So, I created a virtual environment to keep everything tidy and in one place.</p><p>I initialized a python virtual environment to hold any additional modules that would be needed for the scripts to run and activated the environment.
Using a virtual environment allows me to recover easily if an incorrect or incompatible python module gets installed. I can simply delete the venv
directory and recreate the environment without any consequence to the system Python installation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>python -m venv venv
</span></span><span style=display:flex><span>source venv/Scripts/activate
</span></span></code></pre></div><figure class=center><a href=/img/merkury_smart_plug/python_venv_create.png><img src=/img/merkury_smart_plug/python_venv_create.png></a><figcaption class=center>Setup python virtual environment</figcaption></figure><p>The <code>uartprogram</code> script requires a a few modules that I don&rsquo;t yet have setup in my virtual environment, so I received a few errors when attempting to run it.
The Python <code>pip</code> command is used to install the missing modules:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pip install pyserial
</span></span><span style=display:flex><span>pip install tqdm
</span></span></code></pre></div><p> </p><p>I was then able to run <code>python ./uartprogram --help</code> to get the options.<figure class=center><a href=/img/merkury_smart_plug/uartprogram_usage.png><img src=/img/merkury_smart_plug/uartprogram_usage.png></a><figcaption class=center><code>uartprogram</code> program usage</figcaption></figure></p><p> </p><p>Before attempting to write any firmware to the chipset, I needed to test if I could <em>read</em> from the chipset properly. I see from the usage that I need to use the
<code>-d</code>, <code>-b</code>, and <code>-r</code> options to specify the <em>device</em>, <em>speed</em>, and <em>output file</em>.</p><p>For the device to be in program mode I need to bring the CEN to ground for a moment while <code>uartprogram</code> is <code>Getting Bus...</code>, resetting the device. This is the reason I wired the reset
switch to the CEN, but I could get the same result by touching the CEN contact to GND or a quick disconnect/reconnect of GND.</p><p>I started the application to read with the following command, and as soon as it said <code>Getting Bus...</code>
I briefly grounded the CEN with the reset button and released. It took a few repeated tries to get the timing correct, just pressing and releasing the button every second or so,
but it eventually took and started reading.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>python ./uartprogram -d COM6 -b <span style=color:#ae81ff>115200</span> -r ./firmware.bin
</span></span></code></pre></div><p><figure class=center><a href=/img/merkury_smart_plug/firmware_read.png><img src=/img/merkury_smart_plug/firmware_read.png></a><figcaption class=center>Reading the device application firmware</figcaption></figure><figure class=center><a href=/img/merkury_smart_plug/firmware_read_success.png><img src=/img/merkury_smart_plug/firmware_read_success.png></a><figcaption class=center>Completed firmware read test</figcaption></figure></p><p>By default this script starts at address 0x11000, so this is only the application part of flash not including the bootloader. I was also able to copy the entire flash including
bootloader by specifying <code>-s 0x000000</code> in the command to read. In the end for this project I didn&rsquo;t <em>need</em> the bootloader, but I did break something on a later project and it came
in very handy to rescue a bricked device.</p><p>I now have logging and flash reading! Now on to the final goal, writing.</p><hr><p> </p><h2 id=preparing-a-development-environment>Preparing a Development Environment
<a href=#preparing-a-development-environment class=h-anchor aria-hidden=true>#</a></h2><pre><code>Prerequisites:
- Microsoft Visual Studio Code
- PlatformIO extension for VSCode
</code></pre><p> <br>Before I&rsquo;m able to flash new firmware, I have to have firmware to flash. I have a few options available depending on my intentions for the device.</p><ul><li><a href=https://github.com/tuya/tuya-iotos-embeded-sdk-wifi-ble-bk7231t>Tuya SDK</a> for this device is available, meaning I could modify the software for the plug
and also still be able to use the mobile app.</li><li><a href=https://github.com/openshwprojects/OpenBK7231T>OpenBeken</a>, the Tasmota/Esphome replacement based off of the Tuya SDK but also allowing for
the untethering of the device from the Tuya Cloud.</li><li><a href=https://github.com/kuba2k2/libretuya>LibreTuya</a> which creates an Arduino-compatible build environment for Tuya modules using <a href=https://platformio.org/>PlatformIO</a>.</li></ul><p>Because I intend to use this device as an Arduino-like device and not to integrate into home automation, I chose to experiment further with VSCode/PlatformIO/LibreTuya.</p><p> <br>Within VSCode, I installed <a href=https://platformio.org/>PlatformIO</a> according to the <a href=https://platformio.org/install>installation</a>. I then opened a new terminal within VSCode,
and installed the LibreTuya platform into PlatformIO with the command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>platformio platform install https://github.com/kuba2k2/libretuya
</span></span></code></pre></div><p> <br>Everything was now prepared to write my test application and flash the device.</p><hr><p> </p><h2 id=the-final-boss---flashing>The Final Boss - Flashing
<a href=#the-final-boss---flashing class=h-anchor aria-hidden=true>#</a></h2><p>At this point I was ready to write a simple application to put all of this work to use. I created a New Project within PlatformIO specifying the <code>WB2S</code> board and
using the <code>Arduino</code> framework.</p><table><thead><tr><th style=text-align:center>PlatformIO Menu</th><th style=text-align:center>Creating a New Project</th></tr></thead><tbody><tr><td style=text-align:center><figure class=center><img src=/img/merkury_smart_plug/pio_new.png></figure></td><td style=text-align:center><figure class=center><img src=/img/merkury_smart_plug/pio_new_details.png></figure></td></tr></tbody></table><p> <br>This created a basic Arduino project with setup() and loop() functions. The Serial.println() Arduino function is available, but so is printf(). I wrote a simple &lsquo;Hello World&rsquo;
output to show the firmware is loading properly after flashing.</p><figure class=center><img src=/img/merkury_smart_plug/pio_main.png></figure><p> <br>I then ran the build from the PlatformIO Build button in the bottom left of the IDE to test compile the project into the firmware image.<figure class=center><img src=/img/merkury_smart_plug/pio_build_button.png></figure><figure class=center><img src=/img/merkury_smart_plug/pio_build.png></figure></p><p>In order to upload the image I needed to modify the <code>platformi.ini</code> to specify which COM port I intended to use for upload. Without specifying this, the
program that LibreTuya and PlatformIO use to flash the chip will try to connect to COM3 which is currently connected as the logging adapter. A return to
Device Manager tells me that the programming adapter is found on COM6.<figure class=center><img src=/img/merkury_smart_plug/windows_prog_com.png></figure></p><p>In Linux, more than likely the port needed would be whatever the logging TTY is +1 such as <code>/dev/ttyUSB0</code> for logging and <code>/dev/ttyUSB1</code> for programming.<br>This can be checked again with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls /dev/ttyUSB*
</span></span></code></pre></div><p> <br>After adding <code>upload_port = COM6</code> to the platformio.ini I was ready to try uploading &lsquo;Hello World&rsquo;.<figure class=center><img src=/img/merkury_smart_plug/pio_ini.png></figure></p><p> <br>Using the PlatformIO Upload button this time, the project needed to recompile because of my addition to the <code>platformio.ini</code> and started to upload.
It is during this time that I start slowly and repeatedly pressing the reset button while watching the log in PuTTY until the flash starts. There is
now message specifying that it is flashing, but when it pauses printing text at the <code>ST:</code> line that is the sign. If it makes it to the <code>J</code> line or beyond,
the flash likely failed and will need to be retried. Once the flash is complete, the device should restart automatically and boot to <code>Hello World</code>.<figure class=center><img src=/img/merkury_smart_plug/pio_upload_button.png></figure><figure class=center><img src=/img/merkury_smart_plug/pio_flash.png></figure></p><p> <br>The PuTTY connection shows me the flash was successful and the new application runs with <code>Hello World</code> being printed.<figure class=center><img src=/img/merkury_smart_plug/hello_world.png></figure></p></div></div></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>mascencerro@0x194:~ $</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2022 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=https://0x194.net/assets/main.js></script>
<script src=https://0x194.net/assets/prism.js></script></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-JVGGCM9QQM"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JVGGCM9QQM",{anonymize_ip:!1})}</script></body></html>